package ares

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"golang.org/x/net/proxy"
	"io"
	"io/ioutil"
	"mime"
	"net"
	"net/http"
	"net/http/httputil"
	"os"
	"strings"
	"time"

	"github.com/patrickmn/go-cache"
	"github.com/pborman/uuid"

	"context"
	"crypto/sha256"
	"github.com/gorilla/mux"
	logging "github.com/op/go-logging"
	"gopkg.in/olivere/elastic.v5"
	"net/url"

	"crypto/tls"
	"flag"
	"regexp"
	"rsc.io/letsencrypt"

	"github.com/PuerkitoBio/goquery"
	"path"
)

var log = logging.MustGetLogger("ares:proxy")

var (
	cachePath = flag.String("cache", "letsencrypt.cache", "cache path (default: letsencrypt.cache)")
)

const (
	ApacheFormatPattern = "%s - - [%s] %s \"%s %d %d\" %f\n"
)

type Proxy struct {
	listener net.Listener

	Hosts []Host `toml:"host"`

	Socks            string `toml:"socks"`
	ElasticsearchURL string `toml:"elasticsearch_url"`

	ListenerString    string `toml:"listener"`
	ListenerStringTLS string `toml:"tlslistener"`

	Data string `toml:"data"`

	Logging []struct {
		Output string `toml:"output"`
		Level  string `toml:"level"`
	} `toml:"logging"`

	Cache *cache.Cache

	router *mux.Router

	index chan Document
	p     *Proxy
}

type Host struct {
	Host    string   `toml:"host"`
	Target  string   `toml:"target"`
	Actions []Action `toml:"action"`
}

type Action struct {
	Path        string   `toml:"path"`
	Method      []string `toml:"method"`
	RemoteAddr  []string `toml:"remote_addr"`
	Location    string   `toml:"location"`
	Action      string   `toml:"action"`
	StatusCode  int      `toml:"statuscode"`
	ContentType string   `toml:"content_type"`
	Body        string   `toml:"body"`
	UserAgent   []string `toml:"user_agent"`
	Scripts     []string `toml:"scripts"`

	Regex   string `toml:"regex"`
	Replace string `toml:"replace"`
	File    string `toml:"file"`
}

type Document struct {
	Date       time.Time              `json:"date"`
	RemoteAddr string                 `json:"remote_addr"`
	Meta       map[string]interface{} `json:"meta,omitempty"`
	Request    *Request               `json:"request"`
	Response   *Response              `json:"response,omitempty"`
}

type Request struct {
	Method        string              `json:"method,omitempty"`
	URL           string              `json:"url,omitempty"`
	Proto         string              `json:"proto,omitempty"`
	Host          string              `json:"host,omitempty"`
	Cookies       map[string]string   `json:"cookies,omitempty"`
	ContentLength int64               `json:"content_length,omitempty"`
	Header        map[string][]string `json:"headers,omitempty"`
	Body          string              `json:"body,omitempty"`
}

type Response struct {
	StatusCode    int                 `json:"status_code,omitempty"`
	ContentLength int64               `json:"content_length,omitempty"`
	Proto         string              `json:"proto,omitempty"`
	Header        map[string][]string `json:"headers,omitempty"`
	Body          string              `json:"body,omitempty"`
	Hash          struct {
		SHA256 string `json:"sha256,omitempty"`
	} `json:"hashes,omitempty"`
}

type Transport struct {
	http.RoundTripper

	Proxy *Proxy
}

func filter(action Action, req *http.Request) bool {
	if matched, _ := regexp.MatchString(action.Path, req.URL.Path); matched {
	} else {
		return false
	}

	CheckMethod := func(req *http.Request, methods []string) bool {
		if len(methods) == 0 {
			return true
		}

		for _, method := range methods {
			if method == req.Method {
				return true
			}
		}
		return false
	}

	if !CheckMethod(req, action.Method) {
		return false
	}

	CheckRemoteAddr := func(req *http.Request, addrs []string) bool {
		if len(addrs) == 0 {
			return true
		}

		remoteHost, _, _ := net.SplitHostPort(req.RemoteAddr)
		for _, remoteAddr := range addrs {
			if remoteAddr == remoteHost {
				return true
			}
		}
		return false
	}

	if !CheckRemoteAddr(req, action.RemoteAddr) {
		return false
	}

	CheckUserAgent := func(req *http.Request, agents []string) bool {
		if len(agents) == 0 {
			return true
		}

		for _, agent := range agents {
			if matched, _ := regexp.MatchString(agent, req.UserAgent()); matched {
				return true
			}
		}
		return false
	}

	if !CheckUserAgent(req, action.UserAgent) {
		return false
	}

	return true
}

func HostNotConfigured(req *http.Request) (*http.Response, error) {
	r, w := io.Pipe()

	go func() {
		defer w.Close()

		w.Write([]byte("Host not configured."))
	}()

	return &http.Response{
		Proto:      "HTTP/1.1",
		ProtoMajor: 1,
		ProtoMinor: 1,
		Header:     make(http.Header),
		Body:       r,
		Request:    req,
		StatusCode: 404,
	}, nil
}

func IsMediaType(contentType string, val string) bool {
	mt, _, _ := mime.ParseMediaType(contentType)
	return strings.HasPrefix(mt, val)
}

func (p *Proxy) GetHost(hst string) *Host {
	for _, h := range p.Hosts {
		if v, _, err := net.SplitHostPort(hst); err == nil {
			hst = v
		}

		if hst != h.Host {
			continue
		}

		return &h
	}

	return nil
}

/*
func Save(req *http.Request, resp *http.Response) (*http.Response, error) {
	if resp.StatusCode >= 300 {
		return resp, nil
	}

	hasher := sha256.New()

	rdr := io.TeeReader(resp.Body, hasher)

	var body []byte
	if body, err = ioutil.ReadAll(rdr); err != nil {
		return nil, err
	}

	hash := fmt.Sprintf("%x", hasher.Sum(nil))
	pair.Response.Hash.SHA256 = hash

	extension := ""
	if v, err := mime.ExtensionsByType(resp.Header.Get("Content-Type")); err != nil {
	} else if len(v) == 0 {
	} else {
		extension = v[0]
	}

	path := path.Join(t.Proxy.Data, fmt.Sprintf("/%s/%s/%s", req.URL.Host, string(hash[0]), string(hash[1])))

	for {
		if _, err := os.Stat(fmt.Sprintf("%s/%s%s", path, hash, extension)); os.IsNotExist(err) {
		} else if err != nil {
			log.Errorf("Error stat path: %s", err.Error())
			break
		}

		if err := os.MkdirAll(path, 0750); err != nil {
			log.Errorf("Error creating directory: %s", err.Error())
		} else if err := ioutil.WriteFile(fmt.Sprintf("%s/%s%s", path, hash, extension), body, 0640); err != nil {
			log.Errorf("Error writing to file %s", err.Error())
		}

		break
	}

	resp.Body = ioutil.NopCloser(bytes.NewBuffer(body))

	return resp, nil
}
*/

func (t *Transport) saveToDisk(req *http.Request, resp *http.Response) (*http.Response, error) {
	if resp.StatusCode >= 300 {
		return resp, nil
	}

	hasher := sha256.New()

	rdr := io.TeeReader(resp.Body, hasher)

	var body []byte
	if v, err := ioutil.ReadAll(rdr); err != nil {
		return nil, err
	} else {
		body = v
	}

	hash := fmt.Sprintf("%x", hasher.Sum(nil))

	extension := ""
	if v, err := mime.ExtensionsByType(resp.Header.Get("Content-Type")); err != nil {
	} else if len(v) == 0 {
	} else {
		extension = v[0]
	}

	path := path.Join(t.Proxy.Data, fmt.Sprintf("/%s/%s/%s", req.URL.Host, string(hash[0]), string(hash[1])))

	for {
		if _, err := os.Stat(fmt.Sprintf("%s/%s%s", path, hash, extension)); os.IsNotExist(err) {
		} else if err != nil {
			log.Errorf("Error stat path: %s", err.Error())
			break
		}

		if err := os.MkdirAll(path, 0750); err != nil {
			log.Errorf("Error creating directory: %s", err.Error())
		} else if err := ioutil.WriteFile(fmt.Sprintf("%s/%s%s", path, hash, extension), body, 0640); err != nil {
			log.Errorf("Error writing to file %s", err.Error())
		}

		break
	}

	resp.Body = ioutil.NopCloser(bytes.NewBuffer(body))
	return resp, nil
}

func (t *Transport) RoundTrip(req *http.Request) (resp *http.Response, err error) {
	remoteHost, _, _ := net.SplitHostPort(req.RemoteAddr)

	doc := &Document{
		Date:       time.Now(),
		RemoteAddr: remoteHost,
		Meta: map[string]interface {
		}{},
		Request: &Request{
			Method:        req.Method,
			URL:           req.URL.String(),
			Proto:         req.Proto,
			Header:        req.Header,
			ContentLength: req.ContentLength,
			Host:          req.Host,
			Cookies:       nil,
			Body:          "",
		},
		Response: nil,
	}

	defer func(doc *Document) {
		t.Proxy.index <- *doc
	}(doc)

	host := t.Proxy.GetHost(req.Host)
	if host == nil {
		return HostNotConfigured(req)
	}

	var targetURL *url.URL
	if u, err := url.Parse(host.Target); err != nil {
		return nil, err
	} else {
		targetURL = u
	}

	req.Host = targetURL.Host
	req.URL.Scheme = targetURL.Scheme
	req.URL.Host = targetURL.Host

	dump, _ := httputil.DumpRequest(req, false)
	log.Debugf("Request: %s\n\n", string(dump))

	defer req.Body.Close()

	// update referer to target url
	if val := req.Header.Get("Referer"); val == "" {
	} else if u, err := url.Parse(val); err != nil {
	} else if targetURL.Host == u.Host {
		// replace url and scheme
		u.Scheme = targetURL.Scheme
		u.Host = targetURL.Host

		req.Header.Set("Referer", u.String())
	}

	// read body
	var body []byte
	if body, err = ioutil.ReadAll(req.Body); err == io.EOF {
		return
	} else if err != nil {
		log.Errorf("Error reading body: %s", err.Error())
		return
	}

	// don't like this
	doc.Request.Body = string(body)

	req.Body = ioutil.NopCloser(bytes.NewReader(body))

	for _, action := range host.Actions {
		if !filter(action, req) {
			continue
		}

		var a interface{} = nil

		if action.Action == "redirect" {
			a = &ActionRequestRedirect{
				Action: &action,
			}
		} else if action.Action == "serve" {
			a = &ActionRequestServe{
				Action: &action,
			}
		} else if action.Action == "file" {
			a = &ActionRequestFile{
				Action: &action,
			}
		}

		if a, ok := a.(ActionRequester); !ok {
		} else if req, resp, err = a.OnRequest(req); err != nil {
			log.Errorf("Error executing action: %s: %s", err.Error())
		} else if resp == nil {
		} else {
			// or do we want to have the injector and such run?
			return resp, err
		}
	}

	if resp != nil {
	} else if resp, err = t.RoundTripper.RoundTrip(req); err != nil {
		return nil, err
	}

	defer func() {
		// todo(nl5887): gzip response ?
		resp.Header.Del("Content-Length")

		resp.Header.Set("Server", "Ares (github.com/dutchcoders/ares/)")

		dump, _ = httputil.DumpResponse(resp, false)
		log.Debugf("Response: %s\n", string(dump))
	}()

	// remove gzip encoding
	if resp.Header.Get("Content-Encoding") != "gzip" {
	} else if r, err := gzip.NewReader(resp.Body); err == io.EOF {
	} else if err != nil {
		log.Error("Error decoding gzip body: %s", err)
		return resp, err
	} else {
		resp.Body = r

		resp.Header.Del("Content-Encoding")
		resp.Header.Del("Content-Length")
	}

	doc.Response = &Response{
		StatusCode:    resp.StatusCode,
		Proto:         resp.Proto,
		Header:        resp.Header,
		ContentLength: resp.ContentLength,
		Body:          "",
	}

	cookies := map[string]string{}
	for _, cookie := range req.Cookies() {
		cookies[cookie.Name] = cookie.Value
	}
	doc.Request.Cookies = cookies

	// extraction of form
	if err := req.ParseForm(); err == nil {
		form := map[string][]string{}
		for k, v := range req.Form {
			form[k] = v
		}

		doc.Meta["form"] = form
	} else {
		log.Errorf("Error parsing form: %s", err.Error())
	}

	// extraction of query
	query := map[string][]string{}
	for k, v := range req.URL.Query() {
		query[k] = v
	}
	doc.Meta["query"] = query

	// extraction of basic authentication
	if username, password, ok := req.BasicAuth(); ok {
		doc.Meta["authorization"] = struct {
			Type     string `json:"type"`
			Username string `json:"username"`
			Password string `json:"password"`
		}{
			Type:     "basic",
			Username: username,
			Password: password,
		}
	}

	// todo(nl5887): calculate hash
	if t.Proxy.Data == "" {
	} else if resp, err = t.saveToDisk(req, resp); err != nil {
		log.Error("Error saving response: %s", err.Error())
	}

	for _, action := range host.Actions {
		if !filter(action, req) {
			continue
		}

		var a interface{} = nil

		if action.Action == "inject" {
			a = &ActionResponseInject{
				Action: &action,
			}
		} else if action.Action == "replace" {
			a = &ActionResponseReplace{
				Action: &action,
			}
		}

		if a, ok := a.(ActionResponserer); !ok {
		} else if resp, err = a.OnResponse(req, resp); err != nil {
			log.Errorf("Error executing action: %s: %s", err.Error())
		} else {
			log.Debugf("Executed action: %s", action.Action)
		}
	}

	// we'll only store bodies for html documents
	if !IsMediaType(resp.Header.Get("Content-Type"), "text/html") {
	} else if d, err := goquery.NewDocumentFromReader(resp.Body); err == io.EOF {
		return resp, nil
	} else if err != nil {
		log.Error("Error parsing document: %s", err.Error())
		return resp, err
	} else {
		doc.Response.Body = d.Text()

		html, _ := d.Html()
		resp.Body = ioutil.NopCloser(strings.NewReader(html))
	}

	// rewrite location
	if val := resp.Header.Get("Location"); val == "" {
	} else if u, err := url.Parse(val); err != nil {
	} else if targetURL.Host == u.Host {
		// replace url and scheme
		u.Scheme = req.URL.Scheme
		u.Host = req.URL.Host

		resp.Header.Set("Location", u.String())
	}

	// rewrite cookie domains
	for i, line := range resp.Header["Set-Cookie"] {
		c := parseCookie(line)

		// do we want to remove secure and http only flags?
		c.Domain = host.Host

		resp.Header["Set-Cookie"][i] = c.String()
	}

	return
}

func New() *Proxy {
	c := cache.New(5*time.Minute, 30*time.Second)
	return &Proxy{
		index: make(chan Document, 500),
		Cache: c,
	}
}

func (p *Proxy) indexer() {
	log.Info("Indexer started...")
	defer log.Info("Indexer stopped...")

	es, err := elastic.NewClient(elastic.SetURL(p.ElasticsearchURL), elastic.SetSniff(false))
	if err != nil {
		panic(err)
	}

	bulk := es.Bulk()

	count := 0
	for {
		select {
		case doc := <-p.index:
			docId := uuid.NewUUID()
			bulk = bulk.Add(elastic.NewBulkIndexRequest().
				Index("ares").
				Type("pairs").
				Id(docId.String()).
				Doc(doc),
			)

			log.Debugf("Indexed message with id %s", docId.String())

			// pretty.Print(doc)
			if bulk.NumberOfActions() < 10 {
				continue
			}
		case <-time.After(time.Second * 10):
		}

		if bulk.NumberOfActions() == 0 {
		} else if response, err := bulk.Do(context.Background()); err != nil {
			log.Errorf("Error indexing: %s", err.Error())
		} else {
			indexed := response.Indexed()
			count += len(indexed)

			log.Infof("Bulk indexing: %d total %d.\n", len(indexed), count)
		}
	}
}

func (c *Proxy) ListenAndServe() {
	log.Info("Ares started....")
	defer log.Info("Ares stopped....")

	if c.ElasticsearchURL != "" {
		go c.indexer()
	}

	d := net.Dial

	if c.Socks == "" {
	} else if u, err := url.Parse(c.Socks); err != nil {
		panic(err)
	} else if v, err := proxy.FromURL(u, proxy.Direct); err != nil {
		panic(err)
	} else {
		d = v.Dial
	}

	ph := NewReverseProxy()
	ph.Transport = &Transport{
		RoundTripper: &http.Transport{
			Dial: func(network, addr string) (net.Conn, error) {
				return d(network, addr)
			},
			DialTLS: func(network, addr string) (net.Conn, error) {
				return tls.Dial(network, addr, &tls.Config{})
			},
		},
		Proxy: c,
	}

	var router = mux.NewRouter()
	router.NotFoundHandler = ph

	handler := NewApacheLoggingHandler(router, log.Infof)

	if c.ListenerStringTLS == "" {
	} else {
		go func() {
			var m letsencrypt.Manager
			if err := m.CacheFile(*cachePath); err != nil {
				log.Fatal(err)
			}

			s := &http.Server{
				Addr:    c.ListenerStringTLS,
				Handler: handler,
				TLSConfig: &tls.Config{
					GetCertificate: m.GetCertificate,
				},
			}

			if err := s.ListenAndServeTLS("", ""); err != nil {
				panic(err)
			}
		}()
	}

	server := &http.Server{
		Addr:    c.ListenerString,
		Handler: handler,
	}

	if err := server.ListenAndServe(); err != nil {
		panic(err)
	}
}
